(function () {
  'use strict';

  /*
   * Generated by PEG.js 0.10.0.
   *
   * http://pegjs.org/
   */

  function peg$subclass(child, parent) {
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }

  function peg$SyntaxError(message, expected, found, location) {
    this.message  = message;
    this.expected = expected;
    this.found    = found;
    this.location = location;
    this.name     = "SyntaxError";

    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, peg$SyntaxError);
    }
  }

  peg$subclass(peg$SyntaxError, Error);

  peg$SyntaxError.buildMessage = function(expected, found) {
    var DESCRIBE_EXPECTATION_FNS = {
          literal: function(expectation) {
            return "\"" + literalEscape(expectation.text) + "\"";
          },

          "class": function(expectation) {
            var escapedParts = "",
                i;

            for (i = 0; i < expectation.parts.length; i++) {
              escapedParts += expectation.parts[i] instanceof Array
                ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1])
                : classEscape(expectation.parts[i]);
            }

            return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
          },

          any: function(expectation) {
            return "any character";
          },

          end: function(expectation) {
            return "end of input";
          },

          other: function(expectation) {
            return expectation.description;
          }
        };

    function hex(ch) {
      return ch.charCodeAt(0).toString(16).toUpperCase();
    }

    function literalEscape(s) {
      return s
        .replace(/\\/g, '\\\\')
        .replace(/"/g,  '\\"')
        .replace(/\0/g, '\\0')
        .replace(/\t/g, '\\t')
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r')
        .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
        .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
    }

    function classEscape(s) {
      return s
        .replace(/\\/g, '\\\\')
        .replace(/\]/g, '\\]')
        .replace(/\^/g, '\\^')
        .replace(/-/g,  '\\-')
        .replace(/\0/g, '\\0')
        .replace(/\t/g, '\\t')
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r')
        .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
        .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
    }

    function describeExpectation(expectation) {
      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
    }

    function describeExpected(expected) {
      var descriptions = new Array(expected.length),
          i, j;

      for (i = 0; i < expected.length; i++) {
        descriptions[i] = describeExpectation(expected[i]);
      }

      descriptions.sort();

      if (descriptions.length > 0) {
        for (i = 1, j = 1; i < descriptions.length; i++) {
          if (descriptions[i - 1] !== descriptions[i]) {
            descriptions[j] = descriptions[i];
            j++;
          }
        }
        descriptions.length = j;
      }

      switch (descriptions.length) {
        case 1:
          return descriptions[0];

        case 2:
          return descriptions[0] + " or " + descriptions[1];

        default:
          return descriptions.slice(0, -1).join(", ")
            + ", or "
            + descriptions[descriptions.length - 1];
      }
    }

    function describeFound(found) {
      return found ? "\"" + literalEscape(found) + "\"" : "end of input";
    }

    return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
  };

  function peg$parse(input, options) {
    options = options !== void 0 ? options : {};

    var peg$FAILED = {},

        peg$startRuleFunctions = { program: peg$parseprogram },
        peg$startRuleFunction  = peg$parseprogram,

        peg$c0 = function(p) { return p == "" ? [] : p },
        peg$c1 = function(name, body) { Env.LogoParser.procDict[name] = body; return [{ cmd: "proc", name: name, body: body }]; },
        peg$c2 = "def",
        peg$c3 = peg$literalExpectation("def", false),
        peg$c4 = "ine",
        peg$c5 = peg$literalExpectation("ine", false),
        peg$c6 = function(name) { return name },
        peg$c7 = function(stmt) { return stmt },
        peg$c8 = "end",
        peg$c9 = peg$literalExpectation("end", false),
        peg$c10 = function(name) { return !!Env.LogoParser.procDict[name] },
        peg$c11 = function(name, com) { return Env.LogoParser.procDict[name] ? { cmd: "pname", body: Env.LogoParser.procDict[name] } : null; },
        peg$c12 = "repeat",
        peg$c13 = peg$literalExpectation("repeat", false),
        peg$c14 = "[",
        peg$c15 = peg$literalExpectation("[", false),
        peg$c16 = "]",
        peg$c17 = peg$literalExpectation("]", false),
        peg$c18 = function(cmd, times, moves, com) { return { cmd: cmd, times: times, moves: moves, com: com }; },
        peg$c19 = function(cmd, by, com) { return { cmd: cmd, arg: by, com: com }; },
        peg$c20 = "forward",
        peg$c21 = peg$literalExpectation("forward", false),
        peg$c22 = "fd",
        peg$c23 = peg$literalExpectation("fd", false),
        peg$c24 = function() { return "forward" },
        peg$c25 = "back",
        peg$c26 = peg$literalExpectation("back", false),
        peg$c27 = "bk",
        peg$c28 = peg$literalExpectation("bk", false),
        peg$c29 = function() { return "back" },
        peg$c30 = "right",
        peg$c31 = peg$literalExpectation("right", false),
        peg$c32 = "rt",
        peg$c33 = peg$literalExpectation("rt", false),
        peg$c34 = function() { return "right" },
        peg$c35 = "left",
        peg$c36 = peg$literalExpectation("left", false),
        peg$c37 = "lt",
        peg$c38 = peg$literalExpectation("lt", false),
        peg$c39 = function() { return "left" },
        peg$c40 = "penup",
        peg$c41 = peg$literalExpectation("penup", false),
        peg$c42 = "pendown",
        peg$c43 = peg$literalExpectation("pendown", false),
        peg$c44 = function(cmd, com) { return { cmd: cmd, com: com }; },
        peg$c45 = "color",
        peg$c46 = peg$literalExpectation("color", false),
        peg$c47 = "clr",
        peg$c48 = peg$literalExpectation("clr", false),
        peg$c49 = function(cmd, to, com) { return [ { cmd: "color", arg: to, com: com } ]; },
        peg$c50 = "clear",
        peg$c51 = peg$literalExpectation("clear", false),
        peg$c52 = "cls",
        peg$c53 = peg$literalExpectation("cls", false),
        peg$c54 = function(cmd, com) { return [ { cmd: "clear", com: com } ]; },
        peg$c55 = "home",
        peg$c56 = peg$literalExpectation("home", false),
        peg$c57 = function(cmd, com) { return { cmd: "home", com: com }; },
        peg$c58 = "=",
        peg$c59 = peg$literalExpectation("=", false),
        peg$c60 = function(name, val, com) { if (!Env.LogoParser.varDict[name]) Env.LogoParser.varDict[name] = true; return { cmd: "var", name: name, exp: (name + " = " + val), com: com }; },
        peg$c61 = "+",
        peg$c62 = peg$literalExpectation("+", false),
        peg$c63 = function(left, right) { return left + " + " + right; },
        peg$c64 = "*",
        peg$c65 = peg$literalExpectation("*", false),
        peg$c66 = function(left, right) { return left + " * " + right; },
        peg$c67 = "(",
        peg$c68 = peg$literalExpectation("(", false),
        peg$c69 = ")",
        peg$c70 = peg$literalExpectation(")", false),
        peg$c71 = function(add) { return "(" + add + ")"; },
        peg$c72 = function(name) { return Env.LogoParser.varDict[name] ? name : null; },
        peg$c74 = function(left, right) { return left + right; },
        peg$c75 = function(left, right) { return left * right; },
        peg$c76 = function(add) { return add; },
        peg$c77 = function(name) { return Env.LogoParser.varDict[name] ? Env.LogoParser.varDict[name] : null },
        peg$c78 = function(com) { return [ { cmd: "comment", com: com } ]; },
        peg$c79 = function(com) { return com || '' },
        peg$c80 = ";",
        peg$c81 = peg$literalExpectation(";", false),
        peg$c82 = function(text) { return text.join(""); },
        peg$c83 = /^[ ]/,
        peg$c84 = peg$classExpectation([" "], false, false),
        peg$c85 = /^[a-z]/,
        peg$c86 = peg$classExpectation([["a", "z"]], false, false),
        peg$c87 = function(chars) { var text = chars.join(""); return Env.LogoParser.reserved.indexOf(text) == -1 ? text : null },
        peg$c88 = /^[0-9]/,
        peg$c89 = peg$classExpectation([["0", "9"]], false, false),
        peg$c90 = function(digits) { return parseInt(digits.join(""), 10); },
        peg$c91 = function(chars) { return chars.join(""); },
        peg$c92 = /^[\n\r\u2028\u2029\\\\]/,
        peg$c93 = peg$classExpectation(["\n", "\r", "\u2028", "\u2029", "\\", "\\"], false, false),
        peg$c94 = peg$anyExpectation(),

        peg$currPos          = 0,
        peg$posDetailsCache  = [{ line: 1, column: 1 }],
        peg$maxFailPos       = 0,
        peg$maxFailExpected  = [],
        peg$silentFails      = 0,

        peg$result;

    if ("startRule" in options) {
      if (!(options.startRule in peg$startRuleFunctions)) {
        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
      }

      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }

    function peg$literalExpectation(text, ignoreCase) {
      return { type: "literal", text: text, ignoreCase: ignoreCase };
    }

    function peg$classExpectation(parts, inverted, ignoreCase) {
      return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
    }

    function peg$anyExpectation() {
      return { type: "any" };
    }

    function peg$endExpectation() {
      return { type: "end" };
    }

    function peg$computePosDetails(pos) {
      var details = peg$posDetailsCache[pos], p;

      if (details) {
        return details;
      } else {
        p = pos - 1;
        while (!peg$posDetailsCache[p]) {
          p--;
        }

        details = peg$posDetailsCache[p];
        details = {
          line:   details.line,
          column: details.column
        };

        while (p < pos) {
          if (input.charCodeAt(p) === 10) {
            details.line++;
            details.column = 1;
          } else {
            details.column++;
          }

          p++;
        }

        peg$posDetailsCache[pos] = details;
        return details;
      }
    }

    function peg$computeLocation(startPos, endPos) {
      var startPosDetails = peg$computePosDetails(startPos),
          endPosDetails   = peg$computePosDetails(endPos);

      return {
        start: {
          offset: startPos,
          line:   startPosDetails.line,
          column: startPosDetails.column
        },
        end: {
          offset: endPos,
          line:   endPosDetails.line,
          column: endPosDetails.column
        }
      };
    }

    function peg$fail(expected) {
      if (peg$currPos < peg$maxFailPos) { return; }

      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }

      peg$maxFailExpected.push(expected);
    }

    function peg$buildStructuredError(expected, found, location) {
      return new peg$SyntaxError(
        peg$SyntaxError.buildMessage(expected, found),
        expected,
        found,
        location
      );
    }

    function peg$parseprogram() {
      var s0, s1, s2, s3;

      s0 = [];
      s1 = peg$currPos;
      s2 = peg$parseproc();
      if (s2 === peg$FAILED) {
        s2 = peg$parsestatement();
      }
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parseEOL();
        if (s3 !== peg$FAILED) {
          s2 = peg$c0(s2);
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        s1 = peg$currPos;
        s2 = peg$parseproc();
        if (s2 === peg$FAILED) {
          s2 = peg$parsestatement();
        }
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseEOL();
          if (s3 !== peg$FAILED) {
            s2 = peg$c0(s2);
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      }

      return s0;
    }

    function peg$parseproc() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = peg$parsePSTART();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseEOL();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsePBODY();
          if (s3 !== peg$FAILED) {
            s4 = peg$parsePEND();
            if (s4 !== peg$FAILED) {
              s1 = peg$c1(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsePSTART() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 3) === peg$c2) {
        s1 = peg$c2;
        peg$currPos += 3;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c3); }
      }
      if (s1 !== peg$FAILED) {
        if (input.substr(peg$currPos, 3) === peg$c4) {
          s2 = peg$c4;
          peg$currPos += 3;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c5); }
        }
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseSP();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseALPHA();
            if (s4 !== peg$FAILED) {
              s1 = peg$c6(s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsePBODY() {
      var s0, s1, s2, s3;

      s0 = [];
      s1 = peg$currPos;
      s2 = peg$parsestatement();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseEOL();
        if (s3 !== peg$FAILED) {
          s2 = peg$c7(s2);
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        while (s1 !== peg$FAILED) {
          s0.push(s1);
          s1 = peg$currPos;
          s2 = peg$parsestatement();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseEOL();
            if (s3 !== peg$FAILED) {
              s2 = peg$c7(s2);
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        }
      } else {
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsePEND() {
      var s0;

      if (input.substr(peg$currPos, 3) === peg$c8) {
        s0 = peg$c8;
        peg$currPos += 3;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c9); }
      }

      return s0;
    }

    function peg$parsePNAME() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = peg$parseALPHA();
      if (s1 !== peg$FAILED) {
        s2 = peg$c10(s1);
        if (s2) {
          s2 = void 0;
        } else {
          s2 = peg$FAILED;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseOPT_SP();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseOPT_COM();
            if (s4 !== peg$FAILED) {
              s1 = peg$c11(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsestatement() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parseMOVE();
      if (s2 === peg$FAILED) {
        s2 = peg$parsePEN();
        if (s2 === peg$FAILED) {
          s2 = peg$parseHOME();
          if (s2 === peg$FAILED) {
            s2 = peg$parseRPT();
          }
        }
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parseMOVE();
          if (s2 === peg$FAILED) {
            s2 = peg$parsePEN();
            if (s2 === peg$FAILED) {
              s2 = peg$parseHOME();
              if (s2 === peg$FAILED) {
                s2 = peg$parseRPT();
              }
            }
          }
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 === peg$FAILED) {
        s1 = peg$parseCOLOR();
        if (s1 === peg$FAILED) {
          s1 = peg$parseCLEAR();
          if (s1 === peg$FAILED) {
            s1 = [];
            s2 = peg$parsePNAME();
            if (s2 !== peg$FAILED) {
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$parsePNAME();
              }
            } else {
              s1 = peg$FAILED;
            }
            if (s1 === peg$FAILED) {
              s1 = [];
              s2 = peg$parsePREVAR();
              if (s2 !== peg$FAILED) {
                while (s2 !== peg$FAILED) {
                  s1.push(s2);
                  s2 = peg$parsePREVAR();
                }
              } else {
                s1 = peg$FAILED;
              }
              if (s1 === peg$FAILED) {
                s1 = peg$parseCOMMENT();
              }
            }
          }
        }
      }
      if (s1 !== peg$FAILED) {
        s1 = peg$c7(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseRPT() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 6) === peg$c12) {
        s1 = peg$c12;
        peg$currPos += 6;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c13); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseOPT_SP();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsePRIMARY();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseOPT_SP();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 91) {
                s5 = peg$c14;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c15); }
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parseOPT_SP();
                if (s6 !== peg$FAILED) {
                  s7 = [];
                  s8 = peg$parseMOVE();
                  if (s8 === peg$FAILED) {
                    s8 = peg$parsePEN();
                    if (s8 === peg$FAILED) {
                      s8 = peg$parseHOME();
                      if (s8 === peg$FAILED) {
                        s8 = peg$parseRPT();
                        if (s8 === peg$FAILED) {
                          s8 = peg$parsePREVAR();
                          if (s8 === peg$FAILED) {
                            s8 = peg$parsePNAME();
                          }
                        }
                      }
                    }
                  }
                  if (s8 !== peg$FAILED) {
                    while (s8 !== peg$FAILED) {
                      s7.push(s8);
                      s8 = peg$parseMOVE();
                      if (s8 === peg$FAILED) {
                        s8 = peg$parsePEN();
                        if (s8 === peg$FAILED) {
                          s8 = peg$parseHOME();
                          if (s8 === peg$FAILED) {
                            s8 = peg$parseRPT();
                            if (s8 === peg$FAILED) {
                              s8 = peg$parsePREVAR();
                              if (s8 === peg$FAILED) {
                                s8 = peg$parsePNAME();
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    s7 = peg$FAILED;
                  }
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parseOPT_SP();
                    if (s8 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 93) {
                        s9 = peg$c16;
                        peg$currPos++;
                      } else {
                        s9 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c17); }
                      }
                      if (s9 !== peg$FAILED) {
                        s10 = peg$parseOPT_SP();
                        if (s10 !== peg$FAILED) {
                          s11 = peg$parseOPT_COM();
                          if (s11 !== peg$FAILED) {
                            s1 = peg$c18(s1, s3, s7, s11);
                            s0 = s1;
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseMOVE() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parseFD();
      if (s1 === peg$FAILED) {
        s1 = peg$parseBK();
        if (s1 === peg$FAILED) {
          s1 = peg$parseLT();
          if (s1 === peg$FAILED) {
            s1 = peg$parseRT();
          }
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseOPT_SP();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsePREPRIMARY();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseOPT_SP();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseOPT_COM();
              if (s5 !== peg$FAILED) {
                s1 = peg$c19(s1, s3, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseFD() {
      var s0, s1;

      if (input.substr(peg$currPos, 7) === peg$c20) {
        s0 = peg$c20;
        peg$currPos += 7;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c21); }
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c22) {
          s1 = peg$c22;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c23); }
        }
        if (s1 !== peg$FAILED) {
          s1 = peg$c24();
        }
        s0 = s1;
      }

      return s0;
    }

    function peg$parseBK() {
      var s0, s1;

      if (input.substr(peg$currPos, 4) === peg$c25) {
        s0 = peg$c25;
        peg$currPos += 4;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c26); }
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c27) {
          s1 = peg$c27;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c28); }
        }
        if (s1 !== peg$FAILED) {
          s1 = peg$c29();
        }
        s0 = s1;
      }

      return s0;
    }

    function peg$parseRT() {
      var s0, s1;

      if (input.substr(peg$currPos, 5) === peg$c30) {
        s0 = peg$c30;
        peg$currPos += 5;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c31); }
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c32) {
          s1 = peg$c32;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c33); }
        }
        if (s1 !== peg$FAILED) {
          s1 = peg$c34();
        }
        s0 = s1;
      }

      return s0;
    }

    function peg$parseLT() {
      var s0, s1;

      if (input.substr(peg$currPos, 4) === peg$c35) {
        s0 = peg$c35;
        peg$currPos += 4;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c36); }
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c37) {
          s1 = peg$c37;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c38); }
        }
        if (s1 !== peg$FAILED) {
          s1 = peg$c39();
        }
        s0 = s1;
      }

      return s0;
    }

    function peg$parsePEN() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 5) === peg$c40) {
        s1 = peg$c40;
        peg$currPos += 5;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c41); }
      }
      if (s1 === peg$FAILED) {
        if (input.substr(peg$currPos, 7) === peg$c42) {
          s1 = peg$c42;
          peg$currPos += 7;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c43); }
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseOPT_SP();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseOPT_COM();
          if (s3 !== peg$FAILED) {
            s1 = peg$c44(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseCOLOR() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 5) === peg$c45) {
        s1 = peg$c45;
        peg$currPos += 5;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c46); }
      }
      if (s1 === peg$FAILED) {
        if (input.substr(peg$currPos, 3) === peg$c47) {
          s1 = peg$c47;
          peg$currPos += 3;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c48); }
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseOPT_SP();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsePRIMARY();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseOPT_SP();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseOPT_COM();
              if (s5 !== peg$FAILED) {
                s1 = peg$c49(s1, s3, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseCLEAR() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 5) === peg$c50) {
        s1 = peg$c50;
        peg$currPos += 5;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c51); }
      }
      if (s1 === peg$FAILED) {
        if (input.substr(peg$currPos, 3) === peg$c52) {
          s1 = peg$c52;
          peg$currPos += 3;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c53); }
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseOPT_SP();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseOPT_COM();
          if (s3 !== peg$FAILED) {
            s1 = peg$c54(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseHOME() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 4) === peg$c55) {
        s1 = peg$c55;
        peg$currPos += 4;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c56); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseOPT_SP();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseOPT_COM();
          if (s3 !== peg$FAILED) {
            s1 = peg$c57(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsePREVAR() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parseALPHA();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseOPT_SP();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 61) {
            s3 = peg$c58;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c59); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseOPT_SP();
            if (s4 !== peg$FAILED) {
              s5 = peg$parsePREADD();
              if (s5 !== peg$FAILED) {
                s6 = peg$parseOPT_SP();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parseOPT_COM();
                  if (s7 !== peg$FAILED) {
                    s1 = peg$c60(s1, s5, s7);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parsePREADD() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parsePREMUL();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseOPT_SP();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 43) {
            s3 = peg$c61;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c62); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseOPT_SP();
            if (s4 !== peg$FAILED) {
              s5 = peg$parsePREADD();
              if (s5 !== peg$FAILED) {
                s1 = peg$c63(s1, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parsePREMUL();
      }

      return s0;
    }

    function peg$parsePREMUL() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parsePREPRIMARY();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseOPT_SP();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 42) {
            s3 = peg$c64;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c65); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseOPT_SP();
            if (s4 !== peg$FAILED) {
              s5 = peg$parsePREMUL();
              if (s5 !== peg$FAILED) {
                s1 = peg$c66(s1, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parsePREPRIMARY();
      }

      return s0;
    }

    function peg$parsePREPRIMARY() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$parseNUM();
      if (s0 === peg$FAILED) {
        s0 = peg$parsePREVNAME();
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 40) {
            s1 = peg$c67;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c68); }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseOPT_SP();
            if (s2 !== peg$FAILED) {
              s3 = peg$parsePREADD();
              if (s3 !== peg$FAILED) {
                s4 = peg$parseOPT_SP();
                if (s4 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 41) {
                    s5 = peg$c69;
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c70); }
                  }
                  if (s5 !== peg$FAILED) {
                    s1 = peg$c71(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
      }

      return s0;
    }

    function peg$parsePREVNAME() {
      var s0, s1;

      s0 = peg$currPos;
      s1 = peg$parseALPHA();
      if (s1 !== peg$FAILED) {
        s1 = peg$c72(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseADD() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parseMUL();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseOPT_SP();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 43) {
            s3 = peg$c61;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c62); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseOPT_SP();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseADD();
              if (s5 !== peg$FAILED) {
                s1 = peg$c74(s1, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parseMUL();
      }

      return s0;
    }

    function peg$parseMUL() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parsePRIMARY();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseOPT_SP();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 42) {
            s3 = peg$c64;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c65); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseOPT_SP();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseMUL();
              if (s5 !== peg$FAILED) {
                s1 = peg$c75(s1, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parsePRIMARY();
      }

      return s0;
    }

    function peg$parsePRIMARY() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$parseNUM();
      if (s0 === peg$FAILED) {
        s0 = peg$parseVNAME();
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 40) {
            s1 = peg$c67;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c68); }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseOPT_SP();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseADD();
              if (s3 !== peg$FAILED) {
                s4 = peg$parseOPT_SP();
                if (s4 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 41) {
                    s5 = peg$c69;
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c70); }
                  }
                  if (s5 !== peg$FAILED) {
                    s1 = peg$c76(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
      }

      return s0;
    }

    function peg$parseVNAME() {
      var s0, s1;

      s0 = peg$currPos;
      s1 = peg$parseALPHA();
      if (s1 !== peg$FAILED) {
        s1 = peg$c77(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseCOMMENT() {
      var s0, s1;

      s0 = peg$currPos;
      s1 = peg$parseCOM();
      if (s1 !== peg$FAILED) {
        s1 = peg$c78(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseOPT_COM() {
      var s0, s1;

      s0 = peg$currPos;
      s1 = peg$parseCOM();
      if (s1 === peg$FAILED) {
        s1 = null;
      }
      if (s1 !== peg$FAILED) {
        s1 = peg$c79(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseCOM() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 59) {
        s1 = peg$c80;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c81); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseOPT_SP();
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parseANY_NOT_EOL();
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parseANY_NOT_EOL();
          }
          if (s3 !== peg$FAILED) {
            s1 = peg$c82(s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseOPT_SP() {
      var s0;

      s0 = peg$parseSP();
      if (s0 === peg$FAILED) {
        s0 = null;
      }

      return s0;
    }

    function peg$parseSP() {
      var s0, s1;

      s0 = [];
      if (peg$c83.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c84); }
      }
      if (s1 !== peg$FAILED) {
        while (s1 !== peg$FAILED) {
          s0.push(s1);
          if (peg$c83.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c84); }
          }
        }
      } else {
        s0 = peg$FAILED;
      }

      return s0;
    }

    function peg$parseALPHA() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      if (peg$c85.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c86); }
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          if (peg$c85.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c86); }
          }
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s1 = peg$c87(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseNUM() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      if (peg$c88.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c89); }
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          if (peg$c88.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c89); }
          }
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s1 = peg$c90(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseANY_NOT_EOL() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$currPos;
      peg$silentFails++;
      s3 = peg$parseEOL();
      peg$silentFails--;
      if (s3 === peg$FAILED) {
        s2 = void 0;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parseANY();
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s1 = peg$c91(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseEOL() {
      var s0;

      if (peg$c92.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c93); }
      }

      return s0;
    }

    function peg$parseANY() {
      var s0;

      if (input.length > peg$currPos) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c94); }
      }

      return s0;
    }


      var Env = {};
      try {
        Env = window; 
      } catch(e) { }// fix for test

      Env.LogoParser = Env.LogoParser || {
        reserved : ('def|define|end|repeat|forward|fd|back|bk|right|rt|left|lt|penup|pendown|color|clr|clear|cls|home'.split('|')),
        varDict : {},
        procDict : {}
      };    


    peg$result = peg$startRuleFunction();

    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail(peg$endExpectation());
      }

      throw peg$buildStructuredError(
        peg$maxFailExpected,
        peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
        peg$maxFailPos < input.length
          ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
          : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
      );
    }
  }

  var parser = {
    SyntaxError: peg$SyntaxError,
    parse:       peg$parse
  };

  var Interpreter = (function () {
    var queue = [];
    var history = [];
    var MAX_HISTORY = 10;

    var safeParse = function (text, start) {
      try {
        return parser.parse(text, { startRule: start });
      } catch (e) {
        throw { name: 'SyntaxError', message: 'Bad syntax. Please check line: ' + e.line + ' column: ' + e.column };
      }
    };

    var process = function process(move) {
      var count, index, procedure;
      switch (move.cmd) {
        case 'forward':
        case 'back':
        case 'right':
        case 'left':
        case 'color':
          if (isNaN(move.arg)) {
            move = $.extend(true, {}, move);
            move.arg = safeParse(move.arg, "PRIMARY");
          }
        case 'clear':
        case 'home':
        case 'penup':
        case 'pendown':
          queue.push(move);
          break;
        case 'repeat':
          for (count = 0; count < move.times; count++) {
            for (index in move.moves) {
              process(move.moves[index]);
            }
          }
          break;
        case 'var':
          safeParse(move.exp, "VAR");
          break;
        case 'proc':
          break;
        case 'pname':
          procedure = $.extend(true, [], move.body);
          for (count in procedure) {
            for (index in procedure[count]) {
              process(procedure[count][index]);
            }
          }
          break;
        case 'comment':
          break;
        default:
          throw { name: 'UnknownMove', message: 'Unknown move: ' + move.cmd };
      }
    };

    var addToHistory = function (program) {
      // if present then remove
      var index = history.indexOf(program);
      index != -1 && history.splice(index, 1);

      // add to history
      history.push(program) >= MAX_HISTORY && history.shift();
    };

    return {
      interpret: function (program) {
        var input = [];
        var i, j, statement, move;

        // update history
        addToHistory(program);

        // parse the input
        input = safeParse(program.endsWith("\n") ? program : program.concat("\n"), 'program');

        // process the commands
        for (i in input) {
          statement = input[i];
          for (j in statement) {
            move = statement[j];
            process(move);
          }
        }
      },
      next: function () {
        return queue.length > 0 ? queue.shift() : undefined;
      },
      prev: function (n) {
        var index = history.length - n;
        return (index >= 0) && history[index];
      }
    };

  })();

  var UI = (function () {

    var config = {
      TURTLE_HEIGHT: 25,
      TURTLE_WIDTH: 15,
      TURTLE_COLOR: 3,
      SCREEN_ID: 'screen',
      SCREEN_MPS: 200,
      COLORS: ['#FFFAF0', 'red', '#FFFF31', '#FFA812', '#1F75FE', 'green', '#FAF0BE', '#964B00', '#36454F', '#7FFF00', '#F7E98E']
    };
    var canvas, turtle, color = config.COLORS[config.TURTLE_COLOR];

    var addNewTail = function () {
      if (!turtle.tailOn) return;
      turtle.tail = new fabric.Line([turtle.left, turtle.top, turtle.left, turtle.top], {
        fill: color,
        strokeWidth: 1,
        selectable: false
      });
      canvas.add(turtle.tail);
    };

    var moveBy = function (distance) {
      turtle.set({
        left: (turtle.left + distance * Math.sin(turtle.angle * Math.PI / 180)),
        top: (turtle.top - distance * Math.cos(turtle.angle * Math.PI / 180))
      });

      turtle.tail && turtle.tail.set({ 'x2': turtle.left, 'y2': turtle.top });
      canvas.renderAll();
    };

    var turnBy = function (angle) {
      turtle.setAngle(turtle.angle + angle);
      canvas.renderAll();
      addNewTail();
    };

    var setCanvasSize = function () {
      canvas.setHeight(window.innerHeight - 230);
      canvas.setWidth(window.innerWidth - 220);

      var home = {
        top: Math.floor(canvas.getHeight() / 2 - (config.TURTLE_HEIGHT / 2)),
        left: Math.floor(canvas.getWidth() / 2 - (config.TURTLE_WIDTH / 2))

      };

      if (turtle) {
        turtle.home = home;
      }

      return home;
    };


    return {
      init: function () {
        // init the canvas
        canvas = new fabric.StaticCanvas(config.SCREEN_ID);
        var home = setCanvasSize();

        // bind the window resize to canvas
        $(window).resize(setCanvasSize);

        // create the turtle shape
        turtle = new fabric.Triangle({
          left: home.left,
          top: home.top,
          width: config.TURTLE_WIDTH,
          height: config.TURTLE_HEIGHT,
          fill: color,
          selectable: false
        });

        // add additional properties
        turtle.home = home;
        turtle.tailOn = true;

        // add the objects to the canvas
        canvas.add(turtle);
        addNewTail();
      },
      forward: function (distance) {
        moveBy(distance);
      },
      back: function (distance) {
        moveBy(-distance);
      },
      right: function (angle) {
        turnBy(angle);
      },
      left: function (angle) {
        turnBy(-angle);
      },
      color: function (index) {
        if (index > 0 && index <= config.COLORS.length) {
          color = config.COLORS[index - 1];

          turtle.set({ fill: color });
          addNewTail();
          canvas.renderAll();
        }
      },
      clear: function () {
        canvas.clear();
        color = config.COLORS[config.TURTLE_COLOR];
        turtle.set({
          fill: color,
          left: turtle.home.left,
          top: turtle.home.top,
          angle: 0
        });
        turtle.tailOn = true;
        canvas.add(turtle);
        addNewTail();
        canvas.renderAll();
      },
      penup: function () {
        turtle.tailOn = false;
        turtle.tail = undefined;
      },
      pendown: function () {
        turtle.tailOn = true;
        addNewTail();
      },
      home: function () {
        this.penup();

        turtle.set({
          left: turtle.home.left,
          top: turtle.home.top,
          angle: 0
        });

        this.pendown();

        canvas.renderAll();
      },
      loop: function (queue) {
        var self = this;

        var move = queue.next();

        if (move !== undefined) {
          self[move.cmd].call(self, move.arg);
        }

        window.setTimeout(function () {
          self.loop(queue);
        }, 1000 / config.SCREEN_MPS);
      }
    };
  })();

  var Logo = {
    interpreter: Interpreter,
    ui: UI
  };

  var KeyCodes = {
    ENTER: 13,
    UP: 38,
    DOWN: 40,
    ESC: 27
  };

  var Selector = {
    field: '#field',
    button: '#enter',
    overlay: '#overlay',
    pane: '.pane',
    paneContent: '.pane .content',
    container: '#container',
    multiline: '.multiline',
    messenger: '#messenger',
    tipper: '.tipper',
    error: '#error',
    trySample: '#samples .copy'
  };

  var setFieldSize = function () {
    return $(Selector.field).width(window.innerWidth - 400);
  };

  var toggleMultiline = function () {
    var $this = $(this);
    var pos = $this.offset();
    var height = $this.height();

    if ($this.toggleClass('on').hasClass('on')) {
      $this.data({ height: height }).css({
        left: pos.left,
        bottom: window.innerHeight - (pos.top + height)
      });
    }
  };

  var TOOLTIP_DEFAULTS = {
    style: {
      tip: {
        corner: 'left top'
      },
      classes: 'ui-tooltip-turtle ui-tooltip-rounded ui-tooltip-shadow'
    },
    position: {
      my: 'top left',
      at: 'center right',
      adjust: {
        x: -5,
        y: -15
      },
      target: $(Selector.messenger)
    }
  };

  var initTips = function () {
    $(Selector.tipper).qtip($.extend({}, {
      content: {
        attr: 'tip'
      }
    }, TOOLTIP_DEFAULTS));

    $(Selector.error).qtip($.extend({}, {
      content: {
        text: 'Error!!'
      },
      show: {
        modal: true
      }
    }, TOOLTIP_DEFAULTS));
  };

  var error = function (message) {
    $(Selector.error).qtip('option', 'content.text', message + '<br/>Hit ESC to dismiss.').qtip('show');
  };

  var initMenus = function () {
    var hidePanes = function () {
      $.each($(Selector.pane), function (index, item) {
        $(item).removeClass('active');
      });
    };

    $(document).keyup(function (e) {
      switch (e.which || e.keyCode) {
        case KeyCodes.ESC:
          $(Selector.overlay).hide();
          return false;
      }
    });

    $(Selector.overlay).click(function () {
      $(this).hide();
    });

    $.each($(Selector.paneContent), function (index, item) {
      $(item).click(function (e) {
        e.stopImmediatePropagation();
      });
    });

    $("#buttons a").click(function () {
      var $this = $(this);
      hidePanes();
      $($this.attr('href')).addClass('active');
      $(Selector.overlay).show();
    });

    $.each($(Selector.trySample), function (i, item) {
      $(item).click(function () {
        !$(Selector.multiline).is('.on') && $(Selector.multiline).click();
        $(Selector.field).val($(this).parent().next('.code').text());
        $(Selector.overlay).hide();
      });
    });
  };

  $(document).ready(function () {
    var current = 0;

    // init the canvas
    Logo.ui.init();

    // field operations
    setFieldSize().keydown(function (e) { // wire the field key shortcuts
      var prev;
      var shortcut = !$(Selector.multiline).hasClass('on') || e.ctrlKey;
      switch (e.which || e.keyCode) {
        case KeyCodes.ENTER:
          if (shortcut) {
            $(Selector.button).trigger('click');
            return false;
          }
          return true;
        case KeyCodes.UP:
          if (e.altKey) {
            $(Selector.multiline).trigger('click');
            return false;
          } else if (shortcut) {
            prev = Logo.interpreter.prev(++current);
            prev && $(Selector.field).val(prev) || --current;
            return false;
          }
          return true;
        case KeyCodes.DOWN:
          if (e.altKey) {
            $(Selector.multiline).trigger('click');
            return false;
          } else if (shortcut) {
            prev = Logo.interpreter.prev(--current);
            prev && $(Selector.field).val(prev) || ++current;
            return false;
          }
          return true;
        default: return true;
      }
    })
      .bind({
        'click': function (e) { // stop propagation of event
          e.stopImmediatePropagation();
        },
        'focus': function (e) {
          $(Selector.multiline).addClass('focus');
        },
        'blur': function (e) {
          $(Selector.multiline).removeClass('focus');
        }
      });

    $(window).resize(setFieldSize);

    // wire the multiline widget
    $(Selector.multiline).bind('click', toggleMultiline);

    // wire the button
    $(Selector.button).bind('click', function () {
      try {
        $(Selector.field).val() != '' && Logo.interpreter.interpret($(Selector.field).val().toLowerCase());

        // resets
        $(Selector.field).val("");
        current = 0;
      } catch (e) {
        error(e.message);
      }
    });

    // start the draw loop
    Logo.ui.loop(Logo.interpreter);

    // initiate the tips
    initTips();

    // init the menus
    initMenus();


    // finally show the canvas and hide the splash screen
    setTimeout(function () {
      $(Selector.container).show();
      $(Selector.overlay).hide();
    }, 200);
  });

}());
//# sourceMappingURL=main.js.map
